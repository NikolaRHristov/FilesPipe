var l=async(w,{Fulfilled:a,Failed:o,Accomplished:r,Changed:s,Passed:f,Read:u,Wrote:p})=>{let t=w;for(const[i,g]of t.Results)try{if(t.On.Input=g,t.On.Output=i,t.On.Before=(await O(t.On.Input)).size,u&&p){t.On.Buffer=await u(t.On);const n=await p(t.On);if(!n)continue;if(t.On.Buffer=n,f&&await f(t.On)){try{await(await import("fs/promises")).access(c(t.On.Output),(await import("fs")).constants.W_OK)}catch{await(await import("fs/promises")).mkdir(c(t.On.Output),{recursive:!0})}if(await(await import("fs/promises")).writeFile(t.On.Output,t.On.Buffer,"utf-8"),t.On.After=(await O(t.On.Output)).size,t.Logger>0&&(t.Files++,s&&(t=await s(t))),t.Logger>1&&typeof r=="function"){const e=await r(t.On);e&&e.length>0&&console.log(e)}}}}catch(n){if(t.Results.delete(i),typeof o=="function"){const e=await o(t.On,n);e&&e.length>0&&console.log(e)}else t.Logger>1&&console.log(n)}if(t.Logger>0&&t.Results.size>0&&typeof a=="function"){const i=await a(t);i&&i.length>0&&console.log(i)}return t};const{stat:O}=await import("fs/promises"),{dirname:c}=await import("path");export{l as default,c as dirname,O as stat};
