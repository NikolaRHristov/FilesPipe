var u=async(n,t)=>{let e=n;for(const[i,o]of e.Results){e.On.Input=o,e.On.Output=i;try{if(e.On.Before=(await r(e.On.Input)).size,t.Read&&t.Wrote){if(e.On.Buffer=await t.Read(e.On),e.On.Buffer=await t.Wrote(e.On),!e.On.Buffer)continue;if(t.Passed&&await t.Passed(e.On)){try{await(await import("fs/promises")).access(f(e.On.Output),(await import("fs")).constants.W_OK)}catch{await(await import("fs/promises")).mkdir(f(e.On.Output),{recursive:!0})}if(await(await import("fs/promises")).writeFile(e.On.Output,e.On.Buffer,"utf-8"),e.On.After=(await r(e.On.Output)).size,e.Logger>0&&(e.Files++,t.Changed&&(e=await t.Changed(e))),e.Logger>1&&typeof t.Accomplished=="function"){const a=await t.Accomplished(e.On);a&&a.length>0&&console.log(a)}}}}catch(a){if(e.Results.delete(e.On.Output),typeof t.Failed=="function"){const s=await t.Failed(e.On,a);s&&s.length>0&&console.log(s)}else e.Logger>1&&console.log(a)}}if(e.Logger>0&&e.Results.size>0&&typeof t.Fulfilled=="function"){const i=await t.Fulfilled(e);i&&i.length>0&&console.log(i)}return e};const{stat:r}=await import("fs/promises"),{dirname:f}=await import("path");export{u as default,f as dirname,r as stat};
