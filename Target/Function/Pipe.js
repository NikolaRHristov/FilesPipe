var l=async(c,{Accomplished:a,Changed:n,Failed:o,Fulfilled:r,Passed:f,Read:u,Wrote:s})=>{let t=c;for(const[i,w]of t.Results){t.On.Input=w,t.On.Output=i;try{if(t.On.Before=(await p(t.On.Input)).size,u&&s){if(t.On.Buffer=await u(t.On),t.On.Buffer=await s(t.On),!t.On.Buffer)continue;if(f&&await f(t.On)){try{await(await import("fs/promises")).access(O(t.On.Output),(await import("fs")).constants.W_OK)}catch{await(await import("fs/promises")).mkdir(O(t.On.Output),{recursive:!0})}await(await import("fs/promises")).writeFile(t.On.Output,t.On.Buffer,"utf-8"),t.On.After=(await p(t.On.Output)).size,t.Logger>0&&(t.Files++,n&&(t=await n(t))),t.Logger>1&&typeof a=="function"&&console.log(await a(t.On))}}}catch(e){t.Results.delete(t.On.Output),typeof o=="function"?console.log(await o(t.On,e)):t.Logger>1&&console.log(e)}}if(t.Logger>0&&t.Results.size>0&&typeof r=="function"){const i=await r(t);i&&i.length>0&&console.log(i)}return t};const{stat:p}=await import("fs/promises"),{dirname:O}=await import("path");export{l as default,O as dirname,p as stat};
