const{stat:p}=await import("fs/promises"),{dirname:O}=await import("path");var g=async(l,{Fulfilled:o,Failed:a,Accomplished:r,Changed:f,Passed:s,Read:u,Wrote:c})=>{let t=l;for(const[i,w]of t.Results)try{if(t.On.Input=w,t.On.Output=i,t.On.Before=(await p(t.On.Input)).size,u&&c){t.On.Buffer=await u(t.On);const e=await c(t.On);if(!e)continue;if(t.On.Buffer=e,s&&await s(t.On)){try{await(await import("fs/promises")).access(O(t.On.Output),(await import("fs")).constants.W_OK)}catch{await(await import("fs/promises")).mkdir(O(t.On.Output),{recursive:!0})}if(await(await import("fs/promises")).writeFile(t.On.Output,t.On.Buffer,"utf-8"),t.On.After=(await p(t.On.Output)).size,t.Logger>0&&(t.Files++,f&&(t=await f(t))),t.Logger>1&&typeof r=="function"){const n=await r(t.On);n&&n.length>0&&console.log(n)}}}}catch(e){if(t.Results.delete(i),typeof a=="function"){const n=await a(t.On,e);n&&n.length>0&&console.log(n)}else t.Logger>1&&console.log(e)}if(t.Logger>0&&t.Results.size>0&&typeof o=="function"){const i=await o(t);i&&i.length>0&&console.log(i)}return t};export{g as default,O as dirname,p as stat};
